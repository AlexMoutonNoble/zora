{"version":3,"file":"zora.js","sources":["../src/protocol.js","../src/test.js","../../node_modules/fast-deep-equal/index.js","../src/assertion.js","../../node_modules/@lorenzofox3/for-await/dist/bundle/module.js","../src/reporter.js","../src/harness.js","../src/index.js"],"sourcesContent":["/**\n * Emitted when a new sub test has started\n * @param {{description}} test - A Test\n * @param {number} offset - give the nested level\n * @returns {StartTestMessage}\n */\nexport const startTestMessage = (test, offset) => ({\n    type: \"TEST_START\" /* TEST_START */,\n    data: test,\n    offset\n});\n/**\n * Emitted when an assertion result is produced. Note than when a sub test finishes, it also emits an assertion result in the parent sub test stream\n * @param {TestResult | AssertionResult} assertion\n * @param {number} offset - give the nested level\n * @returns {AssertionMessage}\n */\nexport const assertionMessage = (assertion, offset) => ({\n    type: \"ASSERTION\" /* ASSERTION */,\n    data: assertion,\n    offset\n});\n/**\n * Emitted when a sub tests finishes\n * @param {Test} test - The Sub test\n * @param {number} offset - the nested level\n * @returns {TestEndMessage}\n */\nexport const endTestMessage = (test, offset) => ({\n    type: \"TEST_END\" /* TEST_END */,\n    data: test,\n    offset\n});\n/**\n * Emitted when an error is not handled\n * @param {Error} error\n * @param {number} offset\n * @returns {BailoutMessage}\n */\nexport const bailout = (error, offset) => ({\n    type: \"BAIL_OUT\" /* BAIL_OUT */,\n    data: error,\n    offset\n});\n","import { assert } from './assertion';\nimport { assertionMessage, bailout, endTestMessage, startTestMessage } from './protocol';\nexport const defaultTestOptions = Object.freeze({\n    offset: 0,\n    skip: false\n});\n// todo directive (todo & skip)\nexport const tester = (description, spec, { offset = 0, skip = false } = defaultTestOptions) => {\n    let id = 0;\n    let pass = true;\n    let executionTime = 0;\n    let error = null;\n    const assertions = [];\n    const collect = item => assertions.push(item);\n    const testRoutine = (async function () {\n        try {\n            const start = Date.now();\n            const result = await spec(assert(collect, offset));\n            executionTime = Date.now() - start;\n            return result;\n        }\n        catch (e) {\n            error = e;\n        }\n    })();\n    return Object.defineProperties({\n        [Symbol.asyncIterator]: async function* () {\n            await testRoutine;\n            for (const assertion of assertions) {\n                assertion.id = ++id;\n                if (assertion[Symbol.asyncIterator]) {\n                    // Sub test\n                    yield startTestMessage({ description: assertion.description }, offset);\n                    yield* assertion;\n                    if (assertion.error !== null) {\n                        // Bubble up the error and return\n                        error = assertion.error;\n                        pass = false;\n                        return;\n                    }\n                }\n                yield assertionMessage(assertion, offset);\n                pass = pass && assertion.pass;\n            }\n            return error !== null ? yield bailout(error, offset) : yield endTestMessage(this, offset);\n        }\n    }, {\n        routine: {\n            value: testRoutine\n        },\n        description: {\n            value: description,\n            enumerable: true\n        },\n        pass: {\n            enumerable: true,\n            get() {\n                return pass;\n            }\n        },\n        executionTime: {\n            enumerable: true,\n            get() {\n                return executionTime;\n            }\n        },\n        length: {\n            enumerable: true,\n            get() {\n                return assertions.length;\n            }\n        },\n        fullLength: {\n            enumerable: true,\n            get() {\n                return assertions.reduce((acc, curr) => acc + (curr.fullLength !== void 0 ? curr.fullLength : 1), 0);\n            }\n        },\n        error: {\n            get() {\n                return error;\n            }\n        }\n    });\n};\n","'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n","import { defaultTestOptions, tester } from './test';\n//@ts-ignore\n// (todo check what is wrong here, either with rollup if I use typescript namespace either with typescript as no default import)\nimport equal from 'fast-deep-equal';\nexport const isAssertionResult = (result) => {\n    return 'operator' in result;\n};\nconst getAssertionLocation = () => {\n    const err = new Error();\n    const stack = (err.stack || '').split('\\n');\n    return (stack[3] || '').trim().replace(/^at/i, '');\n};\nconst assertMethodHook = (fn) => function (...args) {\n    // @ts-ignore\n    const assertResult = fn(...args);\n    if (assertResult.pass === false) {\n        assertResult.at = getAssertionLocation();\n    }\n    this.collect(assertResult);\n    return assertResult;\n};\nconst aliasMethodHook = (methodName) => function (...args) {\n    return this[methodName](...args);\n};\nexport const AssertPrototype = {\n    equal: assertMethodHook((actual, expected, description = 'should be equivalent') => ({\n        pass: equal(actual, expected),\n        actual,\n        expected,\n        description,\n        operator: \"equal\" /* EQUAL */\n    })),\n    equals: aliasMethodHook('equal'),\n    eq: aliasMethodHook('equal'),\n    deepEqual: aliasMethodHook('equal'),\n    notEqual: assertMethodHook((actual, expected, description = 'should not be equivalent') => ({\n        pass: !equal(actual, expected),\n        actual,\n        expected,\n        description,\n        operator: \"notEqual\" /* NOT_EQUAL */\n    })),\n    notEquals: aliasMethodHook('notEqual'),\n    notEq: aliasMethodHook('notEqual'),\n    notDeepEqual: aliasMethodHook('notEqual'),\n    is: assertMethodHook((actual, expected, description = 'should be the same') => ({\n        pass: Object.is(actual, expected),\n        actual,\n        expected,\n        description,\n        operator: \"is\" /* IS */\n    })),\n    same: aliasMethodHook('is'),\n    isNot: assertMethodHook((actual, expected, description = 'should not be the same') => ({\n        pass: !Object.is(actual, expected),\n        actual,\n        expected,\n        description,\n        operator: \"isNot\" /* IS_NOT */\n    })),\n    notSame: aliasMethodHook('isNot'),\n    ok: assertMethodHook((actual, description = 'should be truthy') => ({\n        pass: Boolean(actual),\n        actual,\n        expected: 'truthy value',\n        description,\n        operator: \"ok\" /* OK */\n    })),\n    truthy: aliasMethodHook('ok'),\n    notOk: assertMethodHook((actual, description = 'should be falsy') => ({\n        pass: !Boolean(actual),\n        actual,\n        expected: 'falsy value',\n        description,\n        operator: \"notOk\" /* NOT_OK */\n    })),\n    falsy: aliasMethodHook('notOk'),\n    fail: assertMethodHook((description = 'fail called') => ({\n        pass: false,\n        actual: 'fail called',\n        expected: 'fail not called',\n        description,\n        operator: \"fail\" /* FAIL */\n    })),\n    throws: assertMethodHook((func, expected, description) => {\n        let caught;\n        let pass;\n        let actual;\n        if (typeof expected === 'string') {\n            [expected, description] = [description, expected];\n        }\n        try {\n            func();\n        }\n        catch (err) {\n            caught = { error: err };\n        }\n        pass = caught !== undefined;\n        actual = caught && caught.error;\n        if (expected instanceof RegExp) {\n            pass = expected.test(actual) || expected.test(actual && actual.message);\n            actual = actual && actual.message || actual;\n            expected = String(expected);\n        }\n        else if (typeof expected === 'function' && caught) {\n            pass = actual instanceof expected;\n            actual = actual.constructor;\n        }\n        return {\n            pass,\n            actual,\n            expected,\n            description: description || 'should throw',\n            operator: \"throws\" /* THROWS */,\n        };\n    }),\n    doesNotThrow: assertMethodHook((func, expected, description) => {\n        let caught;\n        if (typeof expected === 'string') {\n            [expected, description] = [description, expected];\n        }\n        try {\n            func();\n        }\n        catch (err) {\n            caught = { error: err };\n        }\n        return {\n            pass: caught === undefined,\n            expected: 'no thrown error',\n            actual: caught && caught.error,\n            operator: \"doesNotThrow\" /* DOES_NOT_THROW */,\n            description: description || 'should not throw'\n        };\n    })\n};\nexport const assert = (collect, offset) => Object.assign(Object.create(AssertPrototype, { collect: { value: collect } }), {\n    test(description, spec, opts = defaultTestOptions) {\n        const subTest = tester(description, spec, Object.assign({}, defaultTestOptions, opts, { offset: offset + 1 }));\n        collect(subTest);\n        return subTest.routine;\n    }\n});\n","// with two arguments\nconst curry = (fn) => (a, b) => b === void 0 ? b => fn(a, b) : fn(a, b);\nconst toCurriedIterable = gen => curry((a, b) => ({\n    [Symbol.asyncIterator]() {\n        return gen(a, b);\n    }\n}));\nconst toIterable = gen => (...args) => ({\n    [Symbol.asyncIterator]() {\n        return gen(...args);\n    }\n});\n\nconst map = toCurriedIterable(async function* (fn, asyncIterable) {\n    let index = 0;\n    for await (const i of asyncIterable) {\n        yield fn(i, index, asyncIterable);\n        index++;\n    }\n});\n\nconst filter = toCurriedIterable(async function* (fn, asyncIterable) {\n    let index = 0;\n    for await (const i of asyncIterable) {\n        if (fn(i, index, asyncIterable) === true) {\n            yield i;\n        }\n        index++;\n    }\n});\n\nconst take = toCurriedIterable(async function* (number, asyncIterable) {\n    let count = 1;\n    for await (const i of asyncIterable) {\n        if (number !== undefined && count > number) {\n            break;\n        }\n        yield i;\n        count++;\n    }\n});\n\nconst skip = toCurriedIterable(async function* (limit, asyncIterable) {\n    let count = 0;\n    for await (const i of asyncIterable) {\n        if (count < limit) {\n            count++;\n            continue;\n        }\n        yield i;\n    }\n});\n\nconst flatMap = toCurriedIterable(async function* (fn, asyncIterable) {\n    for await (const i of asyncIterable) {\n        if (i[Symbol.asyncIterator]) {\n            yield* map(fn, i);\n        } else {\n            yield fn(i);\n        }\n    }\n});\n\nconst acutalSlice = toIterable(async function* (s, e, iterable) {\n    const toSkip = skip(s);\n    const toTake = take(e !== void 0 ? e - s : e);\n    for await (const i of toTake(toSkip(iterable))) {\n        yield i;\n    }\n});\nconst slice = (start, end, asyncIterable) => {\n    let s = start || 0;\n    let e = end;\n    let iterable = asyncIterable;\n    if (start && start[Symbol.asyncIterator] !== void 0) {\n        iterable = start;\n        s = 0;\n        e = void 0;\n    } else if (end && end[Symbol.asyncIterator] !== void 0) {\n        iterable = end;\n        s = start;\n        e = void 0;\n    } else if (asyncIterable === void 0) {\n        return iterable => acutalSlice(s, e, iterable);\n    }\n    return acutalSlice(s, e, iterable);\n};\n\nconst concat = toIterable(async function* (...values) {\n    for (const i of values) {\n        if (i[Symbol.asyncIterator]) {\n            yield* i;\n        } else {\n            yield i;\n        }\n    }\n});\n\nconst actualReduce = async (fn, initialValue, asyncIterable) => {\n    let index = -1;\n    const iterator = asyncIterable[Symbol.asyncIterator]();\n    const next = async () => {\n        index++;\n        return iterator.next();\n    };\n    let acc = initialValue;\n\n    if (initialValue === void 0) {\n        acc = (await next()).value;\n    }\n\n    while (true) {\n        const {value, done} = await next();\n        if (done === true) {\n            return acc;\n        }\n        acc = fn(acc, value, index, asyncIterable);\n    }\n};\nconst reduce = (fn, initVal, asyncIterable) => {\n    let acc = initVal;\n    let iterable = asyncIterable;\n\n    if (initVal && initVal[Symbol.asyncIterator] !== void 0) {\n        iterable = initVal;\n        acc = void 0;\n    }\n\n    if (iterable === void 0) {\n        return iterable => actualReduce(fn, acc, iterable);\n    }\n\n    return actualReduce(fn, acc, iterable);\n};\n\nconst findTuple = async (fn, asyncIterable) => {\n    let index = 0;\n    for await (const i of asyncIterable) {\n        if (fn(i, index, asyncIterable)) {\n            return {value: i, index: index};\n        }\n        index++;\n    }\n    return {value: void 0, index: -1};\n};\n\nconst find = curry(async (fn, asyncIterable) => (await findTuple(fn, asyncIterable)).value);\n\nconst findIndex = curry(async (fn, asyncIterable) => (await findTuple(fn, asyncIterable)).index);\n\nconst actualIncludes = async (item, from, iterable) => {\n    const strictEqualToItem = findIndex(x => x === item);\n    return (await strictEqualToItem(skip(from, iterable))) > -1;\n};\nconst includes = (item, from, asyncIterable) => {\n    let start = from;\n    let iterable = asyncIterable;\n\n    if (from && from[Symbol.asyncIterator] !== void 0) {\n        start = 0;\n        iterable = from;\n    }\n\n    if (iterable === void 0) {\n        return iterable => actualIncludes(item, start, iterable);\n    }\n\n    return actualIncludes(item, start, iterable);\n};\n\nconst every = curry(async (fn, asyncIterable) => {\n    let index = 0;\n    for await(const i of asyncIterable) {\n        if (!fn(i, index, asyncIterable)) {\n            return false;\n        }\n        index++;\n    }\n    return true;\n});\n\nconst some = curry(async (fn, asyncIterable) => {\n    let index = 0;\n    for await(const i of asyncIterable) {\n        if (fn(i, index, asyncIterable)) {\n            return true;\n        }\n        index++;\n    }\n    return false;\n});\n\n/*\n  The iterable won't always be consumed with a for await statement (which implicitly convert an iterable into a asyncIterable) so we need to explicitly make it async iterable\n  for await (const t of [1,2,3,4,5]){\n    //no problem\n  }\n\n  but\n\n  const iterator = [1,2,3][Symbol.asyncIterator]();\n  //problem\n */\nconst toAsync = toIterable(async function* (iterable) {\n    yield* iterable;\n});\n\nconst proto = {\n    [Symbol.asyncIterator]() {\n        return this._source[Symbol.asyncIterator]();\n    },\n    map(fn) {\n        return stream(map(fn, this));\n    },\n    filter(fn) {\n        return stream(filter(fn, this));\n    },\n    flatMap(fn) {\n        return stream(flatMap(fn, this));\n    },\n    slice(start = 0, end = void 0) {\n        return stream(slice(start, end, this));\n    },\n    concat(...values) {\n        return stream(concat(this, ...values));\n    },\n    reduce(fn, initialValue) {\n        return reduce(fn, initialValue, this);\n    },\n    find(fn) {\n        return find(fn, this);\n    },\n    findIndex(fn) {\n        return findIndex(fn, this);\n    },\n    includes(item, from = 0) {\n        return includes(item, from, this);\n    },\n    every(fn) {\n        return every(fn, this);\n    },\n    some(fn) {\n        return some(fn, this);\n    }\n};\n\nconst stream = iterable => {\n    const source = !iterable[Symbol.asyncIterator] ? toAsync(iterable) : iterable; // we make a difference as any wrap of iterable has performance impact (for the moment)\n    return Object.create(proto, {_source: {value: source}});\n};\n\nexport { stream, toAsync as from, map, filter, take, skip, flatMap, slice, concat, reduce, find, findIndex, includes, every, some };\n","import { assertionMessage } from './protocol';\nimport { isAssertionResult } from './assertion';\nimport { filter, map } from '@lorenzofox3/for-await';\nconst print = (message, offset = 0) => {\n    console.log(message.padStart(message.length + (offset * 4))); // 4 white space used as indent (see tap-parser)\n};\nconst printYAML = (obj, offset = 0) => {\n    const YAMLOffset = offset + 0.5;\n    print('---', YAMLOffset);\n    for (const [prop, value] of Object.entries(obj)) {\n        print(`${prop}: ${JSON.stringify(value)}`, YAMLOffset);\n    }\n    print('...', YAMLOffset);\n};\nconst comment = (value, offset) => {\n    print(`# ${value}`, offset);\n};\nconst subTestPrinter = (prefix = '') => (message) => {\n    const { data } = message;\n    const value = `${prefix}${data.description}`;\n    comment(value, message.offset);\n};\nconst mochaTapSubTest = subTestPrinter('Subtest: ');\nconst tapeSubTest = subTestPrinter();\nconst assertPrinter = (diagnostic) => (message) => {\n    const { data, offset } = message;\n    const { pass, description, id } = data;\n    const label = pass === true ? 'ok' : 'not ok';\n    if (isAssertionResult(data)) {\n        print(`${label} ${id} - ${description}`, offset);\n        if (pass === false) {\n            printYAML(diagnostic(data), offset);\n        }\n    }\n    else {\n        print(`${pass ? 'ok' : 'not ok'} ${id} - ${description} # ${data.executionTime}ms`, message.offset);\n    }\n};\nconst tapeAssert = assertPrinter(val => val);\nconst mochaTapAssert = assertPrinter(({ expected, actual, operator, at }) => ({\n    wanted: expected,\n    found: actual,\n    at,\n    operator\n}));\nconst testPrinter = (lengthProp) => (message) => {\n    const length = message.data[lengthProp];\n    const { offset } = message;\n    const isRoot = offset === 0;\n    if (isRoot) {\n        print('');\n    }\n    print(`1..${length}`, offset);\n    if (isRoot) {\n        comment(message.data.pass ? 'ok' : 'not ok', 0);\n    }\n};\nconst mochaTapTest = testPrinter('length');\nconst tapeTest = testPrinter('fullLength');\nconst printBailout = (message) => {\n    print('Bail out! Unhandled error.');\n};\nexport const reportAsMochaTap = (message) => {\n    switch (message.type) {\n        case \"TEST_START\" /* TEST_START */:\n            mochaTapSubTest(message);\n            break;\n        case \"ASSERTION\" /* ASSERTION */:\n            mochaTapAssert(message);\n            break;\n        case \"TEST_END\" /* TEST_END */:\n            mochaTapTest(message);\n            break;\n        case \"BAIL_OUT\" /* BAIL_OUT */:\n            printBailout(message);\n            throw message.data;\n    }\n};\nexport const reportAsTapeTap = (message) => {\n    switch (message.type) {\n        case \"TEST_START\" /* TEST_START */:\n            tapeSubTest(message);\n            break;\n        case \"ASSERTION\" /* ASSERTION */:\n            tapeAssert(message);\n            break;\n        case \"TEST_END\" /* TEST_END */:\n            tapeTest(message);\n            break;\n        case \"BAIL_OUT\" /* BAIL_OUT */:\n            printBailout(message);\n            throw message.data;\n    }\n};\nexport const mochaTapLike = async (stream) => {\n    print('TAP version 13');\n    for await (const message of stream) {\n        reportAsMochaTap(message);\n    }\n};\nconst flatFilter = filter((message) => {\n    return message.type === \"TEST_START\" /* TEST_START */\n        || message.type === \"BAIL_OUT\" /* BAIL_OUT */\n        || (message.type === \"ASSERTION\" /* ASSERTION */ && isAssertionResult(message.data))\n        || (message.type === \"TEST_END\" /* TEST_END */ && message.offset === 0);\n});\nconst flattenStream = (stream) => {\n    let id = 0;\n    const mapper = map(message => {\n        if (message.type === \"ASSERTION\" /* ASSERTION */) {\n            const mappedData = Object.assign({}, message.data, { id: ++id });\n            return assertionMessage(mappedData, 0);\n        }\n        return Object.assign({}, message, { offset: 0 });\n    });\n    return mapper(flatFilter(stream));\n};\nexport const tapeTapLike = async (stream) => {\n    print('TAP version 13');\n    for await (const message of flattenStream(stream)) {\n        reportAsTapeTap(message);\n    }\n};\n","import { assert } from './assertion';\nimport { assertionMessage, endTestMessage, startTestMessage } from './protocol';\nimport { tapeTapLike as tap } from './reporter';\nexport const harnessFactory = () => {\n    const tests = [];\n    const rootOffset = 0;\n    let pass = true;\n    let id = 0;\n    const collect = item => tests.push(item);\n    const api = assert(collect, rootOffset);\n    const instance = Object.create(api, {\n        length: {\n            get() {\n                return tests.length;\n            },\n        },\n        fullLength: {\n            get() {\n                return tests.reduce((acc, curr) => acc + (curr.fullLength !== void 0 ? curr.fullLength : 1), 0);\n            }\n        },\n        pass: {\n            get() {\n                return pass;\n            }\n        }\n    });\n    return Object.assign(instance, {\n        [Symbol.asyncIterator]: async function* () {\n            for (const t of tests) {\n                t.id = ++id;\n                if (t[Symbol.asyncIterator]) {\n                    // Sub test\n                    yield startTestMessage({ description: t.description }, rootOffset);\n                    yield* t;\n                    if (t.error !== null) {\n                        pass = false;\n                        return;\n                    }\n                }\n                yield assertionMessage(t, rootOffset);\n                pass = pass && t.pass;\n            }\n            yield endTestMessage(instance, rootOffset);\n        },\n        report: async (reporter = tap) => {\n            return reporter(instance);\n        }\n    });\n};\n","import { harnessFactory } from './harness';\nimport { mochaTapLike, tapeTapLike } from './reporter';\nlet autoStart = true;\nlet indent = false;\nconst defaultTestHarness = harnessFactory();\nconst rootTest = defaultTestHarness.test.bind(defaultTestHarness);\nrootTest.indent = () => indent = true;\nexport { tapeTapLike, mochaTapLike } from './reporter';\nexport { AssertPrototype, assert } from './assertion';\nexport const test = rootTest;\nexport const equal = defaultTestHarness.equal.bind(defaultTestHarness);\nexport const equals = equal;\nexport const eq = equal;\nexport const deepEqual = equal;\nexport const notEqual = defaultTestHarness.notEqual.bind(defaultTestHarness);\nexport const notEquals = notEqual;\nexport const notEq = notEqual;\nexport const notDeepEqual = notEqual;\nexport const is = defaultTestHarness.is.bind(defaultTestHarness);\nexport const same = is;\nexport const isNot = defaultTestHarness.isNot.bind(defaultTestHarness);\nexport const notSame = isNot;\nexport const ok = defaultTestHarness.ok.bind(defaultTestHarness);\nexport const truthy = ok;\nexport const notOk = defaultTestHarness.notOk.bind(defaultTestHarness);\nexport const falsy = notOk;\nexport const fail = defaultTestHarness.fail.bind(defaultTestHarness);\nexport const throws = defaultTestHarness.throws.bind(defaultTestHarness);\nexport const doesNotThrow = defaultTestHarness.doesNotThrow.bind(defaultTestHarness);\n/**\n * If you create a test harness manually, report won't start automatically and you will\n * have to call the report method yourself. This can be handy if you wish to use another reporter\n * @returns {TestHarness}\n */\nexport const createHarness = () => {\n    autoStart = false;\n    return harnessFactory();\n};\nconst start = () => {\n    if (autoStart) {\n        defaultTestHarness.report(indent ? mochaTapLike : tapeTapLike);\n    }\n};\n// on next tick start reporting\n// @ts-ignore\nif (typeof window === 'undefined') {\n    setTimeout(start, 0);\n}\nelse {\n    // @ts-ignore\n    window.addEventListener('load', start);\n}\n"],"names":["equal","stream","tap"],"mappings":"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"}